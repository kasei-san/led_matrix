# encoding: utf-8
require "led_dataset"

describe LedDataSet do

  subject { LedDataSet.new("aæ¼¢abc") }

  let(:first_data) do
    [
       #12345678901234567890123456789012
      0b00000000000100001000100000000000,
      0b00000000000010001000100000000000,
      0b00000000000011111111111100000000,
      0b00000000000000001000100000000000,
      0b00000000010000000000000000000000,
      0b00111100001000111111111000111100,
      0b01000010001000100010001001000010,
      0b00000010000000100010001000000010,
      0b00111110000010111111111000111110,
      0b01000010000010000010000001000010,
      0b10000010000100111111110010000010,
      0b10000010000100000010000010000010,
      0b10000110001001111111111110000110,
      0b01111010001000000101000001111010,
      0b00000000010000011000110000000000,
      0b00000000010001100000001100000000
    ]
  end

  let(:next_data) do
    [
      0b00000000001000010001000000000000,
      0b00000000000100010001000000000001,
      0b00000000000111111111111000000001,
      0b00000000000000010001000000000001,
      0b00000000100000000000000000000001,
      0b01111000010001111111110001111001,
      0b10000100010001000100010010000101,
      0b00000100000001000100010000000101,
      0b01111100000101111111110001111101,
      0b10000100000100000100000010000101,
      0b00000100001001111111100100000101,
      0b00000100001000000100000100000101,
      0b00001100010011111111111100001101,
      0b11110100010000001010000011110101,
      0b00000000100000110001100000000000,
      0b00000000100011000000011000000000
    ]
  end

  describe '#next' do
    it 'should return next data' do
      # subject.current.map do |bin|
        # p (Array.new(32,'0')+bin.to_s(2).split(//)).last(32).join
      # end

      subject.next.should == first_data
      subject.next.should == next_data
    end


    it 'edge data test' do
      0.upto(38) do
        subject.next
      end

      subject.next.should == [
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00011100000000000000000000000000,
        0b00100010000000000000000000000000,
        0b01000001000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000001000000000000000000000000,
        0b00100010000000000000000000000000,
        0b00011100000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000
      ]
    end
  end

  describe '#current' do
    it 'first #current should return first data' do
      subject.current.should == first_data
    end

    it '#current should change next data' do
      expect{
        subject.next
      }.to change{
        subject.current
      }.from(first_data).to(next_data)
    end
  end

  it '#reset' do
    0.upto(21) do
      subject.next
    end
    subject.reset

    subject.current.should == first_data
  end
end
