# encoding: utf-8
require "led_dataset"

describe LedDataSet do

  subject { LedDataSet.new("aæ¼¢abc") }

  let(:first_data) do
    [
        #12345678901234567890123456789012
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000
    ]
  end

  let(:next_data) do
    [
        #12345678901234567890123456789012
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000001,
       0b00000000000000000000000000000001,
       0b00000000000000000000000000000001,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000,
       0b00000000000000000000000000000000
    ]
  end

  describe '#next' do
    it 'should return next data' do
      subject.next.should == first_data
      subject.next.should == next_data
    end


    it 'edge data test' do
      1.upto(71) do
        subject.next
      end

      subject.next.should == [
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00011100000000000000000000000000,
        0b00100010000000000000000000000000,
        0b01000001000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000000000000000000000000000000,
        0b01000001000000000000000000000000,
        0b00100010000000000000000000000000,
        0b00011100000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000
      ]
    end

    it 'over size test' do
      1.upto(1000) do
        subject.next
      end
      subject.next.should == [
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000,
        0b00000000000000000000000000000000
      ]
      subject.should be_finish
    end
  end

  describe '#finish?' do
    it 'should return false on string not finished' do
      subject.should_not be_finish
    end

    it 'should return false on string finished' do
      subject.should_not be_finish

      (32+48+32).times{ subject.next }

      expect{
        subject.next
      }.to change{
        subject.finish?
      }.from(false).to(true)
    end
  end

  describe '#current' do
    it 'first #current should return first data' do
      subject.current.should == first_data
    end

    it '#current should change next data' do
      expect{
        subject.next
      }.to change{
        subject.current
      }.from(first_data).to(next_data)
    end
  end

  it '#reset' do
    0.upto(21) do
      subject.next
    end
    subject.reset

    subject.current.should == first_data
  end
end
